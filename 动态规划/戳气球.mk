有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。
如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

示例 1：
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167


思路及算法一：
防止越界，创建一个数组val是的num[-1],以及num[sizeof(num) + 1]等于1方便应用 
在i > 0;有val[i - 1] = nums[i]

戳气球想成从往空的val数组（只有头尾为1）加气球，mid为枚举nums数组对应的值；
定义slove(i,j)为戳破所有气球后最大数；
有以下方程：
最大获得硬币数为：
	slove(i,j) = max(from mid = i + 1 to mid = j -1) val[i] * val[mid] * val[j] + slove(i,mid) + slove(mid,j) 	条件：i < j -1
			   = 0  条件：i >= j - 1;

方法二：动态规划
思路及算法
//难
