给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

注意：不允许旋转信封。

示例 1：

输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。

思路：
选择k个信封；宽度w0~wk-1；高度h0~hk-1；
需满足：
    w0 < w1 < ... < wk-1
    h0 < h1 < ... < hk-1
优先控制一个维度,方便分析，固定w维度，将数组envelopes所有信封按w升序排序；则满足w0<= w1 <= ... <= wk-1
<= 和 < 是有区别的；
先考虑w值互不相同的情况下,则可以视为< ,这样就可以考虑h维度
问题变为：
给定一个序列，我们需要找到一个最长的子序列，使得这个子序列中的元素严格单调递增，即上面要求的：
h0 <= h1 <= ... <= hk-1

以上的情况参考300. 最长递增子序列 及其 官方题解。

使用简化版本的方法解决原问题会有什么错误？？

排完序的结果为 [(w,h)]=[(1,1),(1,2),(1,3),(1,4)][(w, h)] = [(1, 1), (1, 2), (1, 3), (1, 4)][(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的 w 值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 1 个信封。然而如果我们完全忽略 w 维度，剩下的 h 维度为 [1,2,3,4][1, 2, 3, 4][1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的 4 个信封了，这就产生了错误。

因此，我们必须要保证对于每一种 w 值，我们最多只能选择 1 个信封。

可以将h值作为第二排序关键字进行降序排序，对于每一种w值其对应的信封在排序后的数组中是按照 h值递减的顺序出现的，那么这些 h 值不可能组成长度超过 1 的严格递增的序列，这就从根本上杜绝了错误的出现。

因此我们就可以得到解决本题需要的方法：

首先我们将所有的信封按照 w 值第一关键字升序、h 值第二关键字降序进行排序；

随后我们就可以忽略 w 维度，求出 h 维度的最长严格递增子序列，其长度即为答案。
----------------------------------------------------------------------------------
基于二分查找的动态规划

设f[j]表示h的前i个元素 可以组成长度为j的最长递增子序列的 末尾元素的 最小值，如果不存在则f无定义；该定义中f值是严格单调递增的，因为越长子序列，末尾元素越大

如果hi 大于 fmax 则hi可以接在f后面
否则 找出f中比hi小的最大元素f[j0] 有f[j0] < hi <= f[j0 + 1]; 这时对f[j0 + 1]进行更新：f[j0+1] = hi;

在遍历所有的 hi之后，f 中最后一个有定义的元素的下标增加 1（下标从 0 开始）即为最长严格递增子序列的长度。

```C++
//lower_bound二分查找
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        if(envelopes.empty()){
            return 0;
        }
        sort(envelopes.begin(),envelopes.end(),[](const auto& e1,const auto& e2){
            return e1[0] < e2[0] || e1[0] == e2[0] && e1[1] >e2[1];
        });
        vector<int>f = {envelopes[0][1]};
        int n = envelopes.size();
        for(int i =1; i < n;i++){
            if(auto num = envelopes[i][1];num > f.back()){
                f.push_back(num);
            }else{
                auto it = lower_bound(f.begin(),f.end(),num);
                *it =  num;
            }
        }
        return f.size();
    }
};


```




